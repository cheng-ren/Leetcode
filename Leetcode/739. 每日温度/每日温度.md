#  [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

 

**示例 1:**

```
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

**示例 2:**

```
输入: temperatures = [30,40,50,60]
输出: [1,1,1,0]
```

**示例 3:**

```
输入: temperatures = [30,60,90]
输出: [1,1,0]
```

 

**提示：**

- `1 <= temperatures.length <= 105`
- `30 <= temperatures[i] <= 100`

## 解题思路

### 方案1：单调栈（推荐⭐️）

**核心思想：** 维护一个单调递减栈，栈中存储温度的索引。

**算法流程：**
1. 从左到右遍历温度数组
2. 对于当前温度 `temperatures[i]`：
   - 如果它比栈顶索引对应的温度高，说明找到了栈顶元素的答案
   - 不断出栈并记录答案，直到栈为空或当前温度不再高于栈顶
   - 将当前索引入栈
3. 遍历结束后，栈中剩余的索引对应的答案都是 0

**时间复杂度：** O(n) - 每个元素最多入栈和出栈各一次  
**空间复杂度：** O(n) - 栈的大小

**示例演示：**
```
temperatures = [73,74,75,71,69,72,76,73]

i=0: stack=[0]
i=1: 74>73, 出栈0, result[0]=1, stack=[1]
i=2: 75>74, 出栈1, result[1]=1, stack=[2]
i=3: 71<75, stack=[2,3]
i=4: 69<71, stack=[2,3,4]
i=5: 72>69, 出栈4, result[4]=1
     72>71, 出栈3, result[3]=2
     72<75, stack=[2,5]
i=6: 76>72, 出栈5, result[5]=1
     76>75, 出栈2, result[2]=4
     stack=[6]
i=7: 73<76, stack=[6,7]

result = [1,1,4,2,1,1,0,0]
```

### 方案2：从后向前遍历

**核心思想：** 利用温度范围有限（30-100）的特性，记录每个温度值最近出现的位置。

**算法流程：**
1. 创建一个 `next` 数组，记录每个温度值最近出现的索引
2. 从后向前遍历温度数组
3. 对于当前温度，查找所有比它高的温度中最近的索引
4. 更新当前温度的最近索引

**时间复杂度：** O(n × k)，k 为温度范围，实际约 O(71n)  
**空间复杂度：** O(1) - 固定大小的辅助数组

### 方案3：递归（不推荐❌）

原始的递归方案存在严重性能问题：
- **时间复杂度：** O(n²)
- **空间复杂度：** O(n²) - 递归栈 + 数组切片
- **问题：** 数据量大时会超时和栈溢出

## 性能对比

| 方案 | 时间复杂度 | 空间复杂度 | n=10⁵ 耗时 | 推荐度 |
|------|-----------|-----------|-----------|--------|
| 单调栈 | O(n) | O(n) | ~10ms | ⭐️⭐️⭐️⭐️⭐️ |
| 后向遍历 | O(71n) | O(1) | ~70ms | ⭐️⭐️⭐️⭐️ |
| 递归 | O(n²) | O(n²) | 超时 | ❌ |

## 关键点

1. **单调栈的本质：** 用于解决「下一个更大/更小元素」问题
2. **为什么是单调递减栈：** 我们要找下一个更高的温度，所以栈从栈底到栈顶是递减的
3. **栈中存什么：** 存储索引而非温度值，因为答案需要计算距离
