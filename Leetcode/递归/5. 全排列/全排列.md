# 46. 全排列

## 题目描述

给定一个不含重复数字的数组 `nums`，返回其所有可能的全排列。你可以按**任意顺序**返回答案。

**示例 1：**
```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**示例 2：**
```
输入：nums = [0,1]
输出：[[0,1],[1,0]]
```

**示例 3：**
```
输入：nums = [1]
输出：[[1]]
```

## 提示

- `1 <= nums.length <= 6`
- `-10 <= nums[i] <= 10`
- `nums` 中的所有整数**互不相同**

## 难度

⭐⭐ 中等

## 学习要点

1. **回溯算法**：递归 + 撤销选择，是递归的重要应用
2. **决策树**：每一步都在做选择，形成一棵决策树
3. **状态跟踪**：需要记录已选择的元素和剩余可选元素
4. **剪枝优化**：避免重复和无效的搜索
5. **深度优先搜索（DFS）**：本质上是 DFS 遍历决策树

## 思路分析

### 回溯模板：
```
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

### 决策树（以 [1,2,3] 为例）：
```
                    []
          /         |         \
        [1]        [2]        [3]
       /   \      /   \      /   \
    [1,2] [1,3] [2,1] [2,3] [3,1] [3,2]
      |     |     |     |     |     |
   [1,2,3][1,3,2][2,1,3][2,3,1][3,1,2][3,2,1]
```

每一层代表一次选择，从根到叶的路径就是一个排列。

## 核心概念

- **路径**：已经做出的选择
- **选择列表**：当前可以做的选择
- **结束条件**：到达决策树的底层（路径长度等于数组长度）

